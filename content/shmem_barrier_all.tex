\apisummary{
    Registers the arrival of a \ac{PE} at a barrier and suspends \ac{PE} execution
    until all other \ac{PE}s arrive at the barrier and all local and remote memory
    updates are completed.
}

\begin{apidefinition}

\begin{Csynopsis}
void shmem_barrier_all(void);
\end{Csynopsis}

\begin{Fsynopsis}
CALL SHMEM_BARRIER_ALL
\end{Fsynopsis}

\begin{apiarguments}

    \apiargument{None.}{}{} 

\end{apiarguments}

\apidescription{   
    The \FUNC{shmem\_barrier\_all} routine registers the arrival of a \ac{PE} at
    a barrier. Barriers are a fast mechanism for synchronizing all \ac{PE}s at
    once.  This routine causes a \ac{PE} to suspend execution until all \ac{PE}s
    have called \FUNC{shmem\_barrier\_all}.  This routine must be used with
    \ac{PE}s started by \FUNC{shmem\_init}.

    Prior to synchronizing with other \ac{PE}s, \FUNC{shmem\_barrier\_all}
    ensures completion of all previously issued memory stores and remote memory
    updates issued via \openshmem{} \acp{AMO} and \ac{RMA} routine calls  such
    as \FUNC{shmem\_int\_add}, \FUNC{shmem\_put32}, 
    \FUNC{shmem\_put\_nbi}, and \FUNC{shmem\_get\_nbi}.
}

\apireturnvalues{
    None.
}

\apinotes{
    {\color{blue}
    The \FUNC{shmem\_barrier\_all} routine can be used to
    portably ensure that memory access operations observe remote updates in the order
    enforced by initiator PEs.}
}

\begin{apiexamples}

\apicexample
    { The following \FUNC{shmem\_barrier\_all} example is for \CorCpp programs:}
    {./example_code/shmem_barrierall_example.c}
    {} 

\end{apiexamples}

\end{apidefinition}
